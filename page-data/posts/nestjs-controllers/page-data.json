{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/nestjs-controllers","result":{"data":{"markdownRemark":{"id":"11e995a0-d835-54b9-aee8-ecedfbadadc3","html":"<h2 id=\"controller\" style=\"position:relative;\"><a href=\"#controller\" aria-label=\"controller permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Controller</h2>\n<ul>\n<li>클라이언트에서 보내는 요청을 처리하고 클라이언트에게 요청을 반환하는 책임을 가진 역할을 담당하는 것</li>\n<li>컨트롤러의 목적은 <strong>어플리케이션을 위한 특정한 요청을 받기 위한 것</strong></li>\n<li>라우팅 메커니즘은 컨트롤러가 어떠한 요청을 처리할 지 제어하는 것</li>\n<li>각 컨트롤러는 하나 이상의 경로를 가지는 경우가 많고, 각기 다른 경로(라우터)들은 다른 액션(비지니스 로직)을 수행함</li>\n<li>NestJS에서 컨트롤러를 생성하기 위해서는, <strong>클래스</strong>와 <strong>데코레이터</strong>를 사용한다.</li>\n<li>데코레이터는 클래스에 필요한 메타 데이터들을 연결하기 위해서 사용하고, Nest가 routing map을 생성하도록 한다. (request에 부합하는 컨트롤러와 묶기 위해서)</li>\n</ul>\n<h2 id=\"routing\" style=\"position:relative;\"><a href=\"#routing\" aria-label=\"routing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Routing</h2>\n<ul>\n<li>컨트롤러를 정의하기 위해서 <code class=\"language-text\">@Controller()</code> 데코레이터 사용</li>\n<li><code class=\"language-text\">@Controller(&#39;cats&#39;)</code> 와 같이 라우트 경로의 prefix를 optional하게 지정할 수 있음</li>\n<li>path prefix를 사용하면 연관이 있는 라우터들을 쉽게 그룹으로 묶을 수 있고, 중복되는 코드를 줄일 수 있음</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Controller<span class=\"token punctuation\">,</span> Get <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@nestjs/common\"</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">Controller</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cats\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CatsController</span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"This action returns all cats\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">$ nest g controller cats</code> 와 같이 CLI를 통해서 쉽게 controller를 생성할 수 있음</p>\n<ul>\n<li><code class=\"language-text\">@Get()</code> HTTP Request 메서드 데코레이터는 Nest 프레임워크에게 HTTP 요청을 위한 특정한 엔드포인트를 처리하는 핸들러를 생성 해준다.</li>\n<li>엔드포인트는 HTTP 요청 메서드와 라우트 경로와 일치하게 된다.</li>\n<li>여기서 라우트 경로란 컨트롤러에서 선언된 prefix와 결합되어 결정된 경로이다.</li>\n<li>위의 코드에서는 findAll의 메서드는 GET /cats 의 라우팅 경로를 가지게 된다.</li>\n<li>Nest 프레임워크는 <code class=\"language-text\">@Controller()</code> 와 <code class=\"language-text\">@Get()</code> 을 통해서 요청을 해당 핸들러와 자동으로 맵핑시켜준다.</li>\n<li><code class=\"language-text\">@Controller()</code> 와 <code class=\"language-text\">@Get()</code> 의 path 설정은 둘 다 optional 하다.</li>\n<li>\n<p>Nest에서는 위의 코드를 실행하면 200 status code를 반환한다. 그 이유는 Nest 에서는 두개의 다른 Response를 조작하는 옵션을 제공하는 개념이 존재</p>\n<ol>\n<li><strong>Standard (recommended)</strong></li>\n</ol>\n<p> 위와 같은 데코레이터 내장 메서드를 사용해 요청을 처리하는 핸들러가 자바스크립트 오브젝트 혹은 배열을 반환할 때, 이것은 자동적으로 JSON으로 직렬화 된다.</p>\n<p> 그러나, 자바스크립트의 원시 타입을 반환할 때는 Nest 프레임워크는 자동적으로 직렬화를 하지 않고 보낸다.</p>\n<p> 이러한 점은 응답의 처리를 간결하게 만들어준다. 단지 우리는 값을 반환하고, Nest 프레임워크가 나머지 부분을 담당해준다.</p>\n<p> 더욱이, 응답 코드는 POST 요청에서 201 응답 코드를 사용하는 것을 제외하고, 항상 200을 기본 값으로 가진다.</p>\n<p> 우리는 이러한 프레임워크의 행동을 <code class=\"language-text\">@HttpCode(...)</code> 데코레이터를 핸들러 레벨에서 추가함으로써 쉽게 변경할 수 있다.</p>\n<ol start=\"2\">\n<li><strong>Library-specific</strong></li>\n</ol>\n<p> 우리는 express와 같은 라이브러리에서 사용하는 응답 객체 (response object)를 <code class=\"language-text\">@Res()</code> 라는 데코레이터에 의해 핸들러 메서드에 주입된 응답 객체를 대신하여 사용할 수 있다.</p>\n<p> 이러한 접근 방식은, 각 라이브러리의 Native한 방식을 사용하여 처리할 수 있다.</p>\n<p> 예를 들어 express에서는 <code class=\"language-text\">response.status(200).send()</code> 와 같이 사용할 수 있다.</p>\n<blockquote>\n<p><strong>Warning</strong></p>\n</blockquote>\n<p>Nest는 핸들러가 library-specific 한 방식을 사용하는 것을 나타내는 <code class=\"language-text\">@Res()</code> 혹은 <code class=\"language-text\">@Next()</code> 사용하는 것을 감지할 수 있다.\n만약 동시에 standard와 library specific한 방식을 사용할 경우 standard 접근 방식은 자동으로 disabled 되고 생각하는 대로 더이상 동작하지 않는다.\n두개의 방식을 동시에 사용하고 싶다면, <code class=\"language-text\">@Res({ passthrough: true })</code> 같이 반드시 옵션을 설정해야 한다.</p>\n</li>\n</ul>\n<h2 id=\"request-object\" style=\"position:relative;\"><a href=\"#request-object\" aria-label=\"request object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Request object</h2>\n<hr>\n<p>핸들러들은 종종 클라이언트 요청에 대한 상세한 정보에 접근할 필요가 있다. Nest 프레임워크는 플랫폼 아래서 <strong>request object</strong>에 접근하는 방법을 제공한다. Nest 프레임워크에서는 <code class=\"language-text\">@Req()</code> 데코레이터를 핸들러 메서드의 시그니쳐에 추가함으로써 요청 객체를 Nest 프레임워크가 주입 할 수 있도록 지시할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Controller<span class=\"token punctuation\">,</span> Get<span class=\"token punctuation\">,</span> Req <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@nestjs/common\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Request <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"express\"</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">Controller</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cats\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CatsController</span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span>@<span class=\"token function\">Req</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> request<span class=\"token operator\">:</span> Request<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"This action returns all cats\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>express 요청 객체에 대한 타입 지원이 필요하다면 <code class=\"language-text\">@types/express</code> 패키지를 설치하면 된다.</p>\n<p>request object는 HTTP 요청을 나타내고, query string, parameters, headers, body 등과 같은 프로퍼티들을 가진다.</p>\n<p>NestJS에서는 이러한 프로퍼티들을 직접 수동으로 사용하지 않고, 데코레이터를 통해서 사용할 수 있다.</p>\n<p>Nest 프레임워크는 HTTP 플랫폼들 (Express와 Fastify 등)간의 타입 호환성을 위해서 <code class=\"language-text\">@Res()</code> 와 <code class=\"language-text\">@Response()</code> 데코레이터들을 제공한다.</p>\n<p><code class=\"language-text\">@Res()</code> 는 단순히 <code class=\"language-text\">@Response()</code> 의 별칭이다. 이 두개의 데코레이터들은 네이티브 플랫폼의 response 객체의 인터페이스에 직접적으로 관련이 있다.</p>\n<p>위의 데코레이터들 사용할 때에는 각 플랫폼에 해당하는 타입 정의를 import 하여 사용하면 된다.</p>\n<p><code class=\"language-text\">@Res()</code> or <code class=\"language-text\">@Response()</code> 를 메서드 핸들러에서 주입을 할 땐, Nest 프레임워크에서 해당 핸들러를 Library-specific mode로 인식하는 것을 기억하고 사용할 때에는 response를 잘 관리하도록 주의를 기울여야한다.</p>\n<h2 id=\"resources\" style=\"position:relative;\"><a href=\"#resources\" aria-label=\"resources permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resources</h2>\n<hr>\n<p>Nest 프레임워크는 모든 표준 HTTP 메서드를 데코레이터들을 통해서 제공한다.</p>\n<ul>\n<li><code class=\"language-text\">@Get()</code></li>\n<li><code class=\"language-text\">@Post()</code></li>\n<li><code class=\"language-text\">@Put()</code></li>\n<li><code class=\"language-text\">@Delete()</code></li>\n<li><code class=\"language-text\">@Patch()</code></li>\n<li><code class=\"language-text\">@Options()</code></li>\n<li><code class=\"language-text\">@Head()</code></li>\n<li><code class=\"language-text\">@All()</code> : 모든 요청을 처리하는 엔드포인트를 정의</li>\n</ul>\n<h2 id=\"route-wildcards\" style=\"position:relative;\"><a href=\"#route-wildcards\" aria-label=\"route wildcards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Route Wildcards</h2>\n<hr>\n<p>Nest 프레임워크는 패턴 기반의 라우팅 또한 지원한다. 예를들어, 와일드 카드(asterisk) 를 사용하여 어떠한 문자열의 조합을 매칭할 수도 있다.</p>\n<ul>\n<li>?, +, *, () 를 라우트 경로로 사용하고, 정규 표현식으로 사용 가능</li>\n<li>하이픈(-) 과 점 (.) 은 문자열 기반 경로로 문자 그대로 해석된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ab*cd'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">'THis route uses a wildcard'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"status-code-상태-코드\" style=\"position:relative;\"><a href=\"#status-code-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\" aria-label=\"status code 상태 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Status Code (상태 코드)</h2>\n<hr>\n<p>Status Code는 POST 요청 (201 status code) 를 제외하고 항상 기본적으로 200 이다.</p>\n<p>핸들러 레벨에서 <code class=\"language-text\">@HttpCode(...)</code> 데코레이터를 추가하여 동작을 쉽게 변경할 수 있다.</p>\n<p><code class=\"language-text\">@HttpCode()</code> 데코레이터는 <code class=\"language-text\">@nestjs/common</code> 로부터 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">HttpCode</span><span class=\"token punctuation\">(</span><span class=\"token number\">204</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">'This action adds a new cat'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"header-헤더\" style=\"position:relative;\"><a href=\"#header-%ED%97%A4%EB%8D%94\" aria-label=\"header 헤더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Header (헤더)</h2>\n<hr>\n<p>사용자 지정 응답 헤더를 사용하려면 <code class=\"language-text\">@Header()</code> 데코레이터를 사용하거나 라이브러리 별 응답 객체를 사용하고 <code class=\"language-text\">res.header()</code> 를 직접 호출 할 수도 있다.</p>\n<p><code class=\"language-text\">@Header()</code> 데코레이터는 <code class=\"language-text\">@nestjs/common</code> 으로 부터 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">Header</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Cache-Control'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">'This action adds a new cat'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"redirection\" style=\"position:relative;\"><a href=\"#redirection\" aria-label=\"redirection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redirection</h2>\n<hr>\n<p>응답을 특정 URL로 redirection 하려면 <code class=\"language-text\">@Redirect()</code> 데코레이터 혹은 <code class=\"language-text\">res.redirect()</code> 를 사용하면 된다.</p>\n<p><code class=\"language-text\">@Redirect()</code> 데코레이터는 필수적으로 url을 입력받고 선택적으로 status Code를 입력받는다. 입력을 생략한다면 디폴트로 302 를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">Redirect</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://nestjs.com'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">301</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>가끔은 동적으로 redirect URL 혹은 HTTP Status code를 반환하기를 원할 때는 핸들러 메서드로 부터 다음과 같은 모양의 오브젝트를 반환하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token punctuation\">{</span>\n\t<span class=\"token string\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token string\">\"statusCode\"</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 반환되는 값들은 <code class=\"language-text\">@Redirect()</code> 데코레이터로 입력되는 값들을 오버라이드한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'docs'</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">Redirect</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://docs.nestjs.com'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">302</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">getDocs</span><span class=\"token punctuation\">(</span>@<span class=\"token function\">Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'version'</span><span class=\"token punctuation\">)</span> version<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>version <span class=\"token operator\">&amp;&amp;</span> verion <span class=\"token operator\">===</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> 'https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>docs<span class=\"token punctuation\">.</span>nestjs<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>v5<span class=\"token operator\">/</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","fields":{"slug":"/posts/nestjs-controllers","tagSlugs":["/tag/nest-js/","/tag/framework/"]},"frontmatter":{"date":"2020-12-04T22:00:00.000Z","description":"NestJS Controller","tags":["NestJS","Framework"],"title":"NestJS - Controllers","socialImage":null}}},"pageContext":{"slug":"/posts/nestjs-controllers"}},"staticQueryHashes":["251939775","3942705351","401334301"]}